{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033\deflangfe1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}{\*\mmathPr\mdispDef1\mwrapIndent1440 }\viewkind4\uc1 
\pard\nowidctlpar\sa200\sl276\slmult1\qc\b\f0\fs32\lang9 Node\par
\par

\pard\nowidctlpar\sa200\sl276\slmult1\fs24 Sta je zapravo NodeJS?\fs32\par

\pard\nowidctlpar\sa200\sl276\slmult1\qj\b0\fs22 Node je javascript runtime izgradjen preko google-ovog v8 javascript engina. Da razlozimo malo ovu definiciju. Do sada smo koristili javascript, medjutim koristili smo ga samo unutar browsera, jer svaki browser izvorno razume html, css i javascript jezik. Nije bitno da li pisemo vanilla JS ili pisemo neki JS framework ili biblioteku (angular, react...). Sve je to JS kod koji se izvrsva unutar browsera, jer svaki browser ima u sebi ugradjen JS \b engine\b0  (koji je zapravo samo program napisan u \b C++ \b0 jeziku i koji ce da izvrsi nas JS kod). U ovom \b slucaju browser je runtime javascripta\b0 . \par
Ali sta ako mozemo da izvedemo JS van browsera i pored toga mozemo da izvrsavamo JS jezik van browsera bez bilo kakvih ogranicanje koja imamo unutar browsera? Ispostavlja se da zapravo to mozemo da uradimo. Resenje za izvrsavanje JS van browsera jeste \b NodeJS\b0 . \b NodeJS \b0 je jos jedan javascript \b runtime\b0 , runtime mozemo da posmatramo kao neki kontejner, dakle kao neko okruzenje u kom program napisan u javascript jeziku moze da se izvrsava, \b ali van browsera\b0 !\b  \b0 Ko zapravo izvrsava taj javascript kod ako ne browser? Tu uskace \b V8 Engine \b0 koji je razvijen od strane google-a. To je upravo mesto gde ce se JS kod parsirati i izvrsiti u \b NodeJS-\b0 u. O tome kako NodeJS funkcionise bice detaljnije objasnjeno nesto kasnije. \par
Sada kada imamo JS van browsera i kada mozemo da ga izvrsavamo van browsera, drugim recima NodeJS, mozemo da radimo puno drugih stvari sa javascriptom koje su ranije bile skroz nemoguce, kao recimo stvari gde pristupamo fajlovima u sistemu, serverske sposobnosti itd. Svi ovi uslovi nam omogucavaju perfektne uslove da koristimo \b NodeJS \b0 kao \b web server. \b0 Sto drugim recima znaci da mozemo da koristimo JS na \b serveru. \b0 Dakle NodeJS mozemo da koristimo za izgradnju brzih, visoko skalabilnih mreznih aplikacija kako bi napajali \b backend \b0 nase aplikacije. \par
Prva stvar o kojoj moramo da pricamo jeste cinjenica da su NodeJS aplikacije izuzetno brze i dosta skalabilne zato sto je NodeJS \b single-threaded, baziran na dogadjajima (event-driven), non-blocking I/O model, \b0 sto ga cini izuzetno lakim i efikasnim. Ovo ga cini perfektnim za izgradnju brzih i skalabilnih aplikacija koja je intezivna sa podacima. Sto ga opet cini savrsenim za izgradnju \b API\b0 -a sa bazom podataka u pozadini, po mogucstvu ne-relacionom odnosno no-sql kao sto je recimo\b  MongoDB\b0 .  Takodje je odlican za izgradnju aplikacije gde se strimuju podaci (kao sto je YouTube), chat aplikacije ili cak server-side web aplikacije, gde se sav sadrzaj renderuje na serveru itd. \par
Naravno postoje slucajevi gde ne bi trebali da koristimo NodeJS. Ovo je slucaj kada je nasoj aplikaciji potrebna super teska obrada podataka na serveru (stvari koje su zahtevne za procesor) , kao sto je recimo velika obrada slika, konverzija videa, kompresija podataka ili bilo sta slicno tome. \par
Najveca prednost NodeJS-a jeste svakako sto koristimo isti jezik i na frontu i na back-u, a to je naravno javascrit. \par
Ukoliko u terminalu ukucamo 'node' to ce pokrenuti node \b REPL\b0 , sto je skracenica za \b ReadEvalPrintLoop\b0 , sto prakticno znaci da posle ove komande mozemo da pisemo javascript kod unutar terminala! To je jos jedan pokazatelj da mozemo da pokrenemo javascript kod van browsera. Da bi izasli iz ovog node procesa mozemo da koristimo '.exit' komandu ili \b ctrl + d\b0 . Ako otvorimo opet \b REPL \b0 proces i stisnemo \b tab, \b0 to ce nam izbaciti sve globalno dostpune promenljive u NodJS-u. Takodje jos jedan trik kada pokrenemo REPL jeste da koristimo _ kako bi pristupili prethodnoj vrednosti. \par
Kako bi pokrenuli neku nodu skriptu dovoljno je da napisete 'node <ime fajla>'. \par
U NodeJS-u se dosta koristi taj koncept modula, to su jednostavno razlicite funkcionalnosti koje su uskladistene u te module. Npr da bi procitali fajlove iz sistema moramo da koristimo \b fs \b0 (sto je skracenica za file sytem)\b  \b0 modul. Kako koristimo te module, pa prosto ih zatrazimo i onda uskladistimo u neku promenljivu:\par
const fs = require('fs');\par
\par
\b Ogranicenja NodeJS-\b0 a?\par
Kao sto smo upoznati do sada, sinhroni kod moze da bude problem ukoliko neka radnja zahteva duze vreme izvrsavanja, tako da bi to blokiralo ostatak koda sve dok se ta jedna linija ne zavrsi, dakle kod sinhronog koda svaka linija ceka na prethodnu da se izvrsi pre nego sto krene sa izvrsavanjem sledeca linija. Za taj problem postoji asinhroni kod, dakle kod koji ce da se izvrsava u pozadini i sav kod kom treba duze vreme izvrsavanja bice izvrsavan u pozadini dok ostatak koda moze neometano da nastavi izvrsavanje. \par
Nesto sto mozemo da primetimo jeste da u NodeJS-u dosta koristimo callback funkcije. Prva stvar koju treba da razumemo jeste cinjenica da u NodeJS procesu, sto je zapravo mesto gde se nasa aplikacija izvrsava, postoji samo \b jedan thread\b0 . Thread je zapravo kao neki set instrukcija koji se izvrsava u kompijuterskom procesoru. Thread je mesto gde se nas kod zapravo izvrsava u procesoru nekog racunara. Sto znaci da je NodeJS zapravo \b single-threaded.\b0  Za svaku aplikaciju postoji samo jedan thread. To opet znaci da \b svi \b0 korisnici koji pristupaju vasoj aplikaciji \b koriste taj jedan thread, \b0 svi pristupaju tom jednom threadu. Kad god korisnici vrse interakciju sa aplikacijom, kod koji se izvrsava za svakog pojedinacnog korisnika bice ceo izvrsen u tom jednom threadu na istom mestu u procesoru racunara na kom je pokrenuta aplikacija, ne bitno da li imali 5 ili 5000 korisnika. To takodje znaci da kada jedan korisnik blokira taj jedan thread izvrsavanja sa nekim sinhronim kodom, svi ostali korisnici morace da cekaju da se to sinhrono (blokirajuce) izvrsavanje zavrsi. To naravno mozda nije problem ako imamo svega 5 korisnika, ali ce definitivno biti problem za 5000 ili pola miliona korisnika \b istovremeno\b0 . Zamislite da korisnik pristupa vasoj aplikaciji i u njoj postoji veliki sinhroni kod koji iscitava neki fajl iz sistema koji ce se izvrsavati celu sekundu da bi ucitao taj fajl, to znaci da za tu jednu sekundu svi ostali korisnici ce morati da cekaju, jer je celo izvrsavanje aplikacije blokirano za tu jednu sekundu dok se ucitava taj fajl iz sistema.  Ukoliko drugi korisnici zele da rade neke prostije i manje zahtevne taskove kao sto je login unutar aplikacije ili jednostavno zahtevaju neke podatke, oni nece moci to da urade, dakle morace da cekaju da se taj fajl ucita! Tek kada se ucita taj fajl svi ostali korisnici ce biti u stanju da izvrse te svoje taskove, jedan za drugim. Ovo je naravno neprihvatljivo korisnicko iskustvo tako da je nas posao kao develera da resimo ovake situacije sa asinhronim kodom! Naravno u ovom konkretnom slucaju da bi resili ovaj problem iscitavanja nekog fajla iz sistema na sinhroni nacin, to mozemo da uradimo na asinhroni nacin. Tako da bi za istu situaciju koristili asinhroni nacin iscitavanja fajla iz sistema, koja umesto da blokira taj jedan thread, ucitava taj fajl u pozadini i ostaje u pozadini sve dok ne zavrsi iscitavanje fajla iz sistema. Posle toga registrujemo callback funckiju koje se poziva jednom kada su podaci dostpuni i ucitani. U ovom scenariu svi ostali korisnici mogu da izvrsavaju svoje taskove u tom jednom threadu, jedan za drugim, dok se taj fajl ucitava u pozadini. Jednom kada se taj fajl ucita, pokrece se callback funkcija da bi se izvrsila u tom glavnom threadu da bi prosesirala taj ucitani fajl. Tako primenjujemo \b Non-blocking I/O model, \b0 o kom smo pricali na pocetku lekcije. I/O je skracenica za \b input/output. \b0 Ovo je jedan od glavnih razloga zato je NodeJS pun callback funkcija. U drugim programskim jezicima poput PHP-a stvari funkcionisu potpuno drugacije, tamo prakticno svaki korisnik dobija svoj jedan thread izvrsavanja, sto je potpuno druga paradigma. \par
\par
\b Introduction to NPM\par
NPM \b0 jeste software koji koristimo za upravljanje sa third party open-source paketima koje biramo da ukljucimo u nas projekat (express, react\'85)\par
Node paket menadzer jeste command line interfejs koja automatski dolazi ukljucena uz node js I koju takodje koristimo da instaliramo I da upravljamo sa open-srouce paketima. Ovi paketi koje smo spomenuli obicno dolaze iz package repozitorijuma koji je takodje NPM. Na npm.js sajtu mozete da vidite sve patkete koji su ukljucueni u repozitorijumu NPM-a. Sto znaci da je NPM I command line iinterfejs koji koristimo da upravljamo tim paketima I u isto vreme jeste I sam repozitorijum sve te pakete. \par
Kada krecemo sa NPM obicno prvo sto radimo jeste da pokrecemo komandu \b npm init, \b0 ovo ce prakticno za nas kreiratni \b package.json\b0  fajl. To je nesto kao konfiguracijski fajl naseg projekta, tu se skladiste razlicite informacije o nasem projektu. Kada budemo krenuli da instaliramo pakete za nas projekat oni ce automatski biti dodati ovde u package.json fajlu tako da mozemo da pratimo koje sve pakete imamo u nasem projektu.   \par
Dva tipa paketa koji mozemo da instaliramo su proste dependencije ili development dependencije. Te proste ili regularne dependecije su prosto paketi koji ukljucuju kod koji cemo mi da ukljucimo unutar naseg koda. Zato ih nazivamo dependencije zato sto nas kod zavisi od njih da radi kako treba. \par
Da bi instalirali neki paket iz NPM-a dovoljno je da iskucamo \b npm install <ime paketa>. \b0 Takodje mozemo da koristimo skracenicu i da napisemo samo slovo \b i \b0 umesto \b install.\par
npm i slugify\par
\b0 Nekada je bilo obavezno staviti i \b --save \b0 na kraju medjutim vise nije neophodno. Dakle pakete koje instaliramo uz pomoce komande \b npm install <ime paketa> \b0 bice instalirani kao proste dependencije i bice dodate pod dependency svojstvom unutar \b package.json\b0  fajlu. \b\par
\b0 Pored ovih prostih dependencija imamo i \b development \b0 dependencije, ovo su samo alati za razvoj (development) aplikacije (stvari poput kod bandlera kao sto je webpack, ili kao sto je debugger alat za testiranje). Ove development   dependencije sluze samo za development okruzenje nisu neophodne za produkciju. Posto nas kod zapravo ne zavisi od njih. Primer jednog takvog development dependent paketa jeste \b nodemon\b0 . Nodemon paket nam pomaze da razvijamo node aplikaciju tako sto automatski restartuje node aplikaciju kada sacuvamo nas kod. \par
Development dependencije instaliramo ovako: \b npm install nodemon --save-dev \b0 ili mozemo da koristimo komandu \b npm install nodemon -D\line\b0 Ova komanda ce da kaze npm-u da zelimo da je smestimo unutar devDependency-a unutar package.json fajla. \par
Sada kada smo pricali o dva tipa dependencija, da kazemo koju rec i o dva tipa instaliranja dependencija. Jer za sada smo instalirali ove pakete samo lokalno, to znaci da ce one raditi samo u ovom projektu, tu kod nas na racunaru. Prilikom instaliranja paketa mozemo da primetimo da je npm dodao kod nas \b node_modules \b0 folder i tu upakovao sve dependencije naseg projekta. Ako otvorimo taj node_modules folder videcemo da se tu nalazio veliki broj foldera dok smo mi za sada instalirali samo dva paketa \b slugify \b0 kao obican dependecy i \b nodemon \b0 kao development dependency, cemu onda sluze ostali paketi. Pa ti folderi sadrze dependencije nasih dependencija, jer npr nas paket \b slugify \b0 zahteva vise tih paketa da bi funkcionisa kako treba. Dakle ceo taj folder node_modules-a \tab sluzi za nasu lokalnu aplikaciju. \par
Uz npm imamo nacin instaliranja paketa globalno. Te pakete koje smo globalno instalirali bice dostpuni bilo gde, ne samo u nasem lokalnom folderu, vec u svim folderima na nasem racunaru. Tako da na primer posto nodemon moze da posluzi za razvitak node aplikacija, mozemo da ga instaliramo globalno kako bi bio dostuupan u svim nasim folderima i svuda na nasem racunaru. Tako nemoramo da ga instaliramo svaki put kada kreiramo novi projekat. \par
Primer instaliranja nekog paketa globalno na vasem racunaru: \b npm install nodemon --global\par
\b0 Sada kada imamo instlairan nodemon globalno mozemo da ga koristimo za razvoj nase node aplikacije tako sto cemo da iskucamo komandu u terminalu \b nodemon index.js (odnosno ime fajla koji zelimo da pokrenemo).\par
\b0 Recimo da nismo instalirali nodemon globalno, kako bi ga onda koristili kao devDependecy lokalno kod nas u folderu gde nam se nalazi aplikacija. Ne bi mogli samo da ga pokrenemo iz comman line-a, zato sto lokalni dependecy ne rade na taj nacin. Ne mozemo da ih koristimo tek tako unutar terminala. Ali ono sto mozemo da radimo jeste da odredimo npm skriptu. Te skripte mozemo da nadjemo pod svojstvom "\b scripts"\b0  unutar package.json fajla. Prilikom npm init komande ona je za nas dodala vec jednu skriptu za test.  \par
Sada mozemo da napravimo nasu start skriptu i da napisemo "nodemon index.js". Tako da sada umesto da pokrecemo komandu dole u terminalu mozemo da stavimo tu komandu pod npm skriptu. Npm skriptu porecemo tako sto ukucamo \b npm run start\b0 . Na ovaj nacin cemo da koristimo nas lokalni devDependecy a ne globalni nodemon. Posto je start skripta nekako podrazumevana kada pokrecemo start skriptu ne moramo cak ni da kucam \b run, \b0 dovoljno je samo \b npm start.\par
\par
Verzije paketa\par
\b0 Svaka verizija npm paketa prati standard notacije semanticke vrednosti, sto znaci da se verzije paketa uvek izrazavaju sa po tri broja. Prvi broj jeste velika verzija. Drugi broj je manja verzija i treci broj je patch verzija. \par
"nodemon": "^2.0.21"\par
Treci broj, sluzi samo da se odkloni neki bug. Recimo da su developeri pronasli gresku u prethodnoj verziji, odmah po odklanjanju tog bug-a promenice patch broj ili ti treci broj.  \par
Drugi broj je manja verzija. Ova verzija predstavlja uvedjenje nekih novih mogucnosti u paket, ali to nisu velike promene. Sto znaci da sve promene koje se odnose na drugi broj bice kompatibilne sa prethodnim brojevima. \par
Prvi broj je velika verzija. Ovaj broj se menja samo kada dodje do velike promene u paketu koji moze da ima promene koje nece raditi sa prethodnim verzijama. Ukoliko se prvi broj promeni to znaci da nas kod mozda nece raditi ako nam je prvi broj manji od trenutnog. \par
"nodemon": "\b ^\b0 2.0.21"\par
Sto se tice simbola koji dolaze ispred broja verzije paketa, on odredjuje koji update mi prihvatamo za svaki od paketa. Ovaj simbol koji npm paket podrazumevano odredjduje, znaci da mi prihvatamo patch u manjoj verziji. \par
\b\par
 - \b0 ako smo rekli da ovaj znak predstavlja zapravo da mi prihvatamo sve patch-eve i sve manje promene verzija (dakle drugi i treci broj). Mi to mozemo da promenimo. Mozemo da ga promenimo u ovaj simbol: \b ~.\par
~ - \b0 Ovaj znak predstavlja da sada prihvatamo samo patch promene u nasoj verziji (dakle samo treci broj), sto ga cini dosta sigurnijim od prvog znaka. \par
\b Kako zapravo updateujemo pakete? \par
\b0 Pakete updateujemo tako sto koristimo komandu \b npm update <ime paketa>\b0\line Naravno ovo ce biti direktno povezano sa znakom koji stoji ispred verzije, dakle ako je znak \b ^ \b0 onda to znaci da nas update da ukljuci promenu drugog i treceg broja, manje promene i patch prmene, dok ako ispred nase verzije stoji znak \b ~ \b0 to znaci da ce update da ukljuci samo najnoviji patch pa toj treutnoj verziji, jer ovaj znak prihvata promene samo treceg broja, odnosno patch promene. \b\par
\b0 Ono sto mozemo da napravimo jeste da ukucamo u terminal \b npm outdated\b0  i to treba da nam da tabelu gde ce biti prikazani paketi koji nisu najnoviji. Ono sto takodje mozemo da uradimo sa npm-om jeste da instaliramo paket po odredjenoj verziji tako sto dodamo posle paketa tacan broj verzije koji zelimo da instaliramo, npr:\par
\b npm install slugify@1.0.0\par
\b0 Brisanje paketa (dependecy) vrsimo tako sto napisemo \b npm uninstall <ime paketa>\par
\b0 Brisanje devDependecy paketa radimo ovako: \b npm uninstall -D <ime paketa>\b0\par
\par
Naravno ono sto je bitno da razumemo sto se tice \b node_modules\b0  foldera jeste da nikada necemo da ga delimo sa nekim ili nikada necemo da saljemo node_modules folder na git repozitorijum prvo zato sto on dosta zauzima a drugo jer lako mozemo da dodjemo do njega preko npm-a. Ako radimo neki projekat na jednom racunaru pa zatim predjemo na neki drugi racunar to vrlo lako mozemo da uradimo pomocu komande \b npm install \b0 sto ce zapravo pogledati u package.json folder i instalirati sve pakete od npm-a koje nadje u package.json fajlu. Takodje jako bitan detalj ovog procesa jeste package-lock.json fajl koji ce da se kreirai i on ce da sadrzi sve verzije nasih paketa koje koristimo u projektu i koje je instalirao \b npm install\b0 . To znaci da ce package-lock.json fajl da sadrzi dependencije nasih depedencija, zapravo sadrzace sve informacije paketa iz node_modules foldera.  \par
\par
\b Node arhitektura\par
\b0 Hajde da predstavimo ovu arhitekturu preko termina node dependencija, sto su zapravo samo par biblioteka od kojih zavisi \b node \b0 da bi funkcionisao pravilno. \b Node runtime \b0 ima nekoliko dependecija, najvaznije su \b V8 \b0 javascript engine i \b libuv \b0 biblioteka\b . \b0 Kao sto smo rekli na pocetku node jeste javascript runtime baziran na googlevom v8 enginu. Da nije ovog v8 engina node ne bi mogao da razume javascript jezik. Taj v8 engine je odgovoran za pretvaranje javascript koda u masinski kod. Medjutim taj v8 engine nije dovoljan da bi node funckionisao. Zato imamo \b libuv. \b0 To je open-source biblioteka sa velikim fokusom na asinhroni \b I/O \b0 (input/output). Ovaj sloj daje nodu pristup kompijuterskom sistemu, fajl sistemu, mrezama i ostalim funkcionalnostima. Pored toga \b libuv \b0 biblioteka implementira dve veoma vazne funkcionalnosti node.js-a, to su \b event-loop \b0 i \b thread pool. \b0 Prostim recima, event-loop je predodoredjen za resavanje laksih zadataka, kao sto je izvrsavanje callback funkcija i mreznog I/O, dok je thread pool vise odgovoran za zahtevnije poslove, kao sto je pristup fajlovima na racunaru ili kompresiju. \b Libuvb \b0 biblioteka je kompletno napisana u C++ jeziku a ne u javascriptu, bas kao sto je i v8 engine napisan u C++ jeziku u kombinaciji sa javascript jezikom. E sad posto node.js runtime sadrzi google v8 engine i libuv biblioteku to znaci da je node.js zapravo program napisan u C++ i JS jeziku.  Lepota ovoga jeste sto node.js veze sve ove biblioteke zajedno nebitno u kom su jeziku pisane, da li u C++ ili u JS. Node.js nama developerima daje pristup funkcijama u cistom javascriptu. Drugim recima pruza jak lepu apstrakciju. Tako da nam node.js daje mogucnost da koristimo cist javascript jezik za npr pristup fajlovima na racunaru koji u pozadini zapravo koristi C++ jezik koje je implementiran u libuv biblioteci. Takodje node.js ne zavisi samo od v8 engina i libuv bibliteke. Tu su jos \b http-parser\b0  biblioteka koja sluzi za parsiranje http protokola, zatim \b c-ares \b0 koji sluzi za DNS zahteve, zatim \b Open-SSL\b0  za kriptografiju i na kraju \b zlib \b0 za kompresiju. Svi ovi delovi sklopljeni u jedno okruzenje jesu zapravo node.js spreman za koriscenje na serveru. \par
\par
\b Single-thread, uvod u event-loop i thread-pool?\b0\par
Kada koristimo node na kompijuteru to znaci da postoji node proces koji je pokrenut na tom kompijuteru. Taj proces je prosto program koji se izvrsava. Kao sto smo napomenuli gore, node.js je zapravo program napisan u C++ jeziku, koji ce pokrenuti taj proces kada se startuje. Ovo je vazno da razumemo je da u nodu imamo pristup proces varijabli koju cemo da koristimo nesto kasnije. U tom procesu node.js pokrece takozvani \b single-thread (thread je zapravo samo set instrukcija). \b0 Taj thread mozemo da zamislimo kao kutiju u kojoj se izvrsava nas kod u kompijuterskom procesoru. Ono sto je bitno da razumemo jeste da se node.js pokrece u \b JEDNOM THREADU\b0 , sto cini da lako mozemo da blokiramo aplikaciju. Dakle jos jednom, ako pokrenem nasu \b node\b0  aplikaciju ona ce da bude pokrenuta samo u jednom threadu izvrsavanja, nebitno da li imali 10 korisnika, 10 000 korisnika ili 10 miliona korisnika koji pristupaju vasoj node aplikaciji u isto vreme. Tako da morate da vodite racuna da ne blokirate taj jedan thread. Hajde sada da razumemo sta se sve desava u tom jednom threadu kada pokrenemo nasu node aplikaciju. Kada je program inicijaliziran ceo top-level kod bice izvrsen (top-level prosto znaci sav kod koji se \b ne nalazi\b0  unutar bilo koje funkcije), takodje svi moduli koje koristimo u aplikaciji i sve callback funkcije bice registrovane. Nakon toga se pokrece \b event-loop. \b0 Ono sto moramo da razumemo za sada jeste da se upravo u tom event-loop-u obavlja veci deo posla. To mozemo da nazovemo samo srce node arhitekture. Ali tu postoji fora. Neki taskovi su jednostavno previse zahtevni za izvrsavanje da bi bili izvrseni unutar \b event-loopa\b0  jer bi onda oni blokirali taj single-thread. Tu nastupa \b thread-pool, \b0 koji bas kao i \b event-loop\b0  jeste obezbedjen node.js-u preko \b libuv \b0 biblioteke. Taj \b thread-pool \b0 nam daje 4 dodatna thread-a koja su potpuno odvojena od glavnog \b single-threada. \b0 Ova cetiri dodatna threada zapravo formiraju taj \b thread-pool. \b0 Tako da sada \b event-loop \b0 moze da prebaci teske taskove unutar \b thread-poola\b0 . Sve se ovo desava automatski iza scene. Nije do nas developera da moramo da odlucujemo sta ide u \b thread-pool\b0  a sta u \b event-loop. \b0 Ti zahtevni zadaci koji se prebacuju iz \b event-loopa \b0 unutar \b thread-poola \b0 imaju veze sa iscitavanjem fajlova iz racunara, sve sto ima veze sa kriptografijom kao sto je hash-ovanje passworda, sve sto ima veze sa kompresijom kao i DNS-lookup koji prakticno spaja domain ime sa pravom ip adresom servera koji gadjamo. Sve su ovo stvari koje bi lako blokirale taj jedan single-thread, tako da ih node automatski prebacuje u thread-pool, gde naravno nece blokirati taj single-thread. \par
\b\par
Event-loop?\par
\b0 Da nastavimo gde smo stali, dakle i dalje smo u tom node procesu u tom single threadu u kom je pokrenut event-loop i prva stvar koju moramo da znamo jeste da se bas ceo aplikacijski kod koji se nalazi unutar callback funkcija izvrsava u event-loopu. Dakle sav kod koji nije top-level kod ce biti izvrsen unutar event-loopa. Neki delovi ce mozda biti prebaceni unutar thread-poola, ali je svakako event-loop taj koji ce da brine o svemu ovome. E sad, kao sto smo spomenuli ranije, node.js je izgradjen oko tih callback funkcija, dakle funkcija koje su pozvane cim se neki posao zavrsi, u nekom trenutku u buducnosti. To je zato sto node koristi event-driven arhitekturu. Ono sto moramo da znamo za sada jeste da bilo da saljemo neki HTTP zahtev, bilo da je timer istekao, bilo da je zavrseno iscitavanje nekog fajla, opalice se neki event cim se zavrse ovi poslovi, zatim ce event-loop da pokupi ove evente i da pozove callback funkcije koje su asocirane sa svakim eventom i eventualno da prebaci neke taskove unutar thread-poola ukoliko postoje zahtevniji zadaci. Medjutim kako sve ovo funkcionise iza scene? U kom redosledu se izvrsavaju ove callback funkcije? \par
Kada startujemo nasu node aplikaciju event-loop se startuje odmah, taj isti event-loop ima vise faza, svaka faza ima \b callback queue\b0 , sto je zapravo callback koji dolaze od dogadjaja (eventa) koje event-loop dobije. Dakle kao sto smo rekli event-loop ima vise faza i svaka njegova faza ima svoj callback queue. Hadje sada da pogledamo 4 najbitnije faze event-loopa:\par
1) Prva faza se nosi sa callback funkcijama od isteklih tajmera, kao na primer iz setTimout funkcije. Dakle ako postoje callback funkcije iz timera koji su istekli oni ce prvi da budu obradjeni od strane event-loopa. Ukoliko ti timeri isteknu kasnije dok traje obrada neke sledece faze, onda ce callback tog tajmera biti pozvan cim event-loop bude dosao do prve faze. U svakoj fazi se izvrsava callback funkcija jedna za drugom sve dok na kraju ne bude bilo vise callback funkcija u toj jednoj fazi i tek nakon toga event-loop prelazi u sledeci fazu. \par
2) Sledeca faza na redu jeste \b I/O polling \b0 i izvrsavanje I/O callback funkcija. I/O jeste skracenica za input/output, dok polling prosto znaci da trazi I/O dogadjaje (evenata) koji su spremni da budu obradjeni i budu stavljeni unutar callback queue-a. U kontekstu node aplikacije I/O se vecinom odnosi na koriscenje mreza, iscitavanje fajlova iz sistema...U ovoj drugoj fazi se izvrsi bukvalno 99 posto naseg koda, prosto zato sto u tipicnoj node aplikaciji ono sto uglavnom radimo jeste da se bavimo mrezama i pristupanju fajlova. \par
3) Treca faza event-loopa jeste za postavljanje \b setImmediate callbacks. setImmediate \b0 jeste poseban timer koji mozemo da koristimo ukoliko zelimo da procesiramo callback funkcije odmah nakon I/O pollinga i njihovog izvrsavanja, sto moze da bude bitno u nekim komplikovanijim stvarima. \par
4) Cetvrta faza ima veze sa \b close callbacks. \b0 U ovoj fazi svi zatvoreni dogadjaji (eventi) su procesuirani npr kada se web server ili web socket  ugasi. \par
Pored ovih cetiri najbitnijih callback queue-a postoje zapravo jos dva. To su \b process.nexttick queue \b0 (koji moze da bude koriscen ukoliko zelimo da izvrsimo neku callback funkciju odmah nakon trenutne faze event-loopa)\b  \b0 i\b  other microtasts queue \b0 koji se vecinom odnosi na resavanje promisa.  Ukoliko postoji bilo koji callback unutar ova dva queue-a koji treba da se procesira i izvrsi oni ce biti izvrseni odmah nakon trenutne faze event-loopa, umesto da cekaju na ceo loop da zavrsi. Drugim recima nakon sve cetiri faze event-loopa ukoliko postoji neki callback iz \b nexttick ili microtasks queue \b0 oni ce biti izvrseni odmah. \par
Ovim smo zavrsili jedan ciklus event-loopa. Sada moramo da odlucimo da li program da nastavi na sledeci ciklus event-loopa ili da izadjemo iz programa. Kako node radi to? Node prosto proveri da li ima neki timera ili I/O zadataka koji se i dalje izvrsavaju u pozadini, ako nema onda ce da izadje iz tog procesa ali ukoliko postoje takvi taskovi onda ce da nastavi da izvrsava event-loop od prve faze. \par
Ono sto moramo da razumemo iz ove lekcije jeste da upravo taj event-loop omogucava asinhrono programiranje mogucim. To je najbitniji detalj u node dizajnu. \par
\b Napomena: \b0 Event loop ce da ceka tokom druge faze (I/O pooling faza (2 faza)) i ako je ta faza bez callback funkcija za izvrsavanje dakle ako nemamo I/O callbacks funkcije, onda ce event-loop da ceka u ovoj fazi sve dok ne bude istekao timer, ali ako smo negde u kodu napisali setImmediate callback funkciju onda ce taj callback da bude izvrsen odmah nakon I/O polling faze i pre isteklih timera ako ih je bilo uopste. Ako unutar druge faze tj I/O polling faze nema callback funkcija za izvrsavanje, event loop ce da ceka da istekne izvrsavanje timera, medjutim ako smo posle toga negde u kodu napisali setImmediate timer on ce prvi da se izvrsi pa tek nakon toga callback iz timera, tj iz prve faze. \b  \par
\par
Events and Event-Driven Architecture\par
\b0 Vecina nodovih glavnih modula kao sto su http, file sistem i timeri izgradjeni su oko dogadjaja (event-a) i te takozvane event-driven arhitekture. Mi takodje mozemo da koristimo ovu arhitekturu za nase potrebe u nasem kodu. Koncept za to je dosta prost. U nodu postoje odredjeni objekti koji se nazivaju \b Event Emitters\b0 . Oni emituju imenovane evente cim se nesto bitno desi unutar aplikacije kao sto je npr request koji pogadja server ili je istekao timer ili je iscitavanje fajla zavrseno. Ove evente onda mozemo da pokupimo pomocu \b event listener-a\b0 , koje mi sami postavljamo koji ce na kraju da pozovu i izvrse callback funkcije koje su zakacene za svaki \b listener. \b0 Dakle jos jednom, na jednu stranu imamo \b Event Emitters\b0  dok na drugoj strani imamo \b Event listener\b0  koji ce da reaguju na emitovani dogadjaj tako sto ce da pozovu callback funkciju. \par
\b\par
Streams\par
\b0 Streams su jos jedan bitan koncept  u nodu. Kao prvo moramo da odgovorimo na pitanje sta su to strimovi (streams). Uz pomoc strimova mozemo da iscitavamo i pisemo podatke deo po deo, bez da kompletiramo celu operaciju pisanja i citanja podtaka. To znaci da ne moramo da drzimo u memoriji sve podatke da bi radili ove operacije (citanja i pisanja deo po deo podataka). Na primer kada citamo neke fajlove uz pomoc strimova mi citamo deo podataka, radimo nesto sa tim delom podataka zatim israznimo nasu memoriju i tako ponavaljamo taj proces sve dok ceo podatak ne bude procesiran. Kao primere mozemo da zamislimo youtube ili netflix. Obe mozemo da nazovemo striming kompanijama. Posto oni strimuju video na istom principu. Tako da umesto da cekamo da se ceo video fajl ucita, procesuiranje se desava deo po deo tako da mozemo da krenemo da gledamo video pre nego sto se ceo fajl download-uje. Streams nije nesto sto je karakteristicno za node, vec je generalno opsti termin u kompijuterskoj nauci. Sve ovo cini \b streams \b0 perfektnim kandidatom za nosenje sa velikim i ogromnim podacima, kao sto su video snimci. Takodje striming cini da procesuiranje podataka \b  \b0 bude dosta efikasnije u svojstvu memorije, zato sto nema potrebe da se cuva ceo podatak u memoriji, zato sto mi mozemo da krenemo da koristimo podatke pre nego sto se ucitaju celi. Hajde sada da pricamo o tome kako su strimovi implemntirani u node.js. \par
U nodu postoje 4 fundamentalana strima: \par
1) Readable stream \par
2) Writable stream\par
3) Duplex stream\par
4) Transform stream\par
\b Readable stream:\b0  Ovo su strimovi kod kojih mozemo da iscitavamo podatke, mozemo da konzumiramo podatke. Prva dva (readable i writable stremas) su najbitnija.  Strimovi su svuda u node core modulima, bas kao i eventi. Na primer podaci koji dodju kada se http zahtev uputi ka serveru jesu zapravo \b readable stream. \b0 Dakle svi podaci koji su poslati uz request dolaze deo po deo, ne u jednom velikom komadu. Jos jedan primer jesu iz fajlova, to znaci da fajlove mozemo da iscitavamo deo po deo, koristeci \b read stream \b0 iz fs modula. Glavni eventi kod readable strema su \b data \b0 i \b end.\b0  Sto se tice glavnih funckija to su \b pipe() \b0 i \b read(). \b0\par
Jos jedna bitna stvar koju moramo da razumemo, jeste da su strimovi zapravo instance Event Emitter klase. To znaci da svi strimovi mogu da emituju i prisluskuju imenovane evente. \par
\b Writable stream: \b0 to su strimovi u koje mozemo upisivati podatke. Odlican primer za writable streamove jesu \b http response\b0 , koje mozemo da posaljemo nazad klijentu. Dakle to je stream u koji mozemo da pisemo podatke. Takodje ukoliko zelimo da posaljemo klijentu veliki video fajl mi bi strimovali taj rezultat bas kao i netflix i youtube. Najvazniji eventi za writable stream jesu \b drain \b0 i \b finish.\b0  Najbitnije funkcije jesu \b write() \b0 i \b end().\b0\par
\b Duplex stream: \b0 to su strimovi koje mozemo i da citamo i pisemo istovremeno. Dobar primer za duple stream bi bio \b web socket \b0 iz net modula. Web socket je prosto komunikacioni kanal izmedju klijenta i servera koji radi u oba smera. Dakle on ostaje otvoren jednom kada se upostavi konekcija izmedju klijenta i servera. \par
\b Transform stream: \b0 to su duplex strimovi koji mogu da transformisu podatke, dakle mogu i da ih citaju i pisu. Primer za to jeste \b zlib\b0  modul. \par
\par
\b How Requiring Modules Really Works:\par
\b0 Kao prvo u node modul sistemu svaki fajl je tretiran kao odvojeni i posebni modul. Node u pozadini koristi \b CommonJS \b0 modul sistem, njega u osnovi cine: \b require(), exports \b0 ili \b module.exports.\b0  Koristi CommonJS jer radi posebno dobro na serveru. Takodje pored njega postoji i nativni ecma script modul sistem koji se koristi u browseru, on koristi \b import/export \b0 sintaksu. Vazno je da razumemo da su ovo dva odvojena modul sistema koja se koriste u razlicitim situacijama. \par
Ako ste se pitali odakle svakom node fajlu pristup \b require() \b0 funkciji i odakle ona dolazi i kako radi u pozadini? Dakle sta se desava svaki put kada mi zatevamo neki modul sa require() funkcijom. Prvo se put do require modula  resava i ucitava, zatim se desava proces koji se naziva \b wrapping\b0  posle toga se modul koda izvrsava i modul export se vraca (returning exports) i na kraju ceo taj modul se kesira. \par
Hajde sada da krenemo deo po deo, kako node zna koji fajl da ucita kada require-uemo neki modul? Setimo se da mozemo dao ucitamo tri tipa modula: node core modul - require('http'), nase module i third party module iz npm-a kao sto je recimo express - require('express'). Ovaj proces je poznat po imenom resovling file path. Evo kako radi: Kada require funckija primi modul ime kao svoj input prvo ce pokusati da ucita core modul sa tim imenom kao npr http modul - require('http'). Automatski ce naci putanju do tog modula i ucitace ga. Ako putanja pocinje sa . ili sa .. (tackom ili dve tacke) to znaci da je developer modul, posto smo mi definisali relativnu putanju do naseg fajla. Tako da ce node pokusati da ucita taj fajl, ali ako ne postji fajl sa tim imenom onda ce pogledati folder umesto toga i unutar foldera ce pokusati da ucita index.js fajl ako ga ima. Npr require('./lib/controller'). Setimo se da ne moramo da definisemo .js extenziju kada ucitavamo module. Ukoliko ne postoji fajl sa ovom putanjom pokusace da nadje folderu lib/controller index.js fajl. Ako fajl nije iz core modula niti je develop modul (nas modul), node ce onda pretpostaviti da je iz npm-a. Kada iscitavamo modul iz paketa sa npm-a ne dovoljno je samo da definisemo ime paketa. Ti paketi ce se nalazti u node_module folderu tako da ce ih node tamo traziti i ucitati. Jednom kada je nas modul ucitan, modulov kod biva obmotan u jednu specijalnu funkciju koja ce nam dati pristup nekoliko specijalnih objekata. Ovo je odgovor na pitanje odakle zapravo dolazi require metoda i kako joj imamo pristup. To je zato sto node runtime uzima kod iz naseg modula i stavalja ga unutar immediatly invoke function expression (IIFE). Dakle ova funkcija je zaduzena za izvrsavanje naseg koda iz modula. \line\par
(function(exports, require, module, __filename, __dirname) \{\par
\tab // module code lives here...\par
\});\par
Zato u svakom moulu imamo pristup ovim stvarima kao sto su exports, require, __filename... Na njih mozemo da gledamo kao na neke globalno dostpune promenljive. Posto one bivaju ubacene u svaki modul preko funkcije koja obmotava svaki nas modul. Ovakav pristup u nodu cini dve stvari, prva je da imamo pristup svim ovi stvarim u svakom modulu a druga jeste da svaka nasa promenlijva bice scopeovana unutar te obmotane funkcije sto znaci da nece biti dostpuna u drugim modulima (fajlovima). Dakle svaki modul ima svoje privatne promenljive. \par
\b require: \b0 funkcija koja zahteva modul\par
\b module: \b0 referenca ka trenutnom modulu\par
\b exports: \b0 referenca ka module.exports, koji se koristi da se exportuju objekti iz modula\par
\b __filename: \b0 absolutna putanja trenutnog modul fajla\par
\b __dirname\b0 : direktorijum ime trenutnog modula\par
Sledeci korak jeste da ceo taj modul odnosno ceo taj modul koji je obmotan unutar funkcije biva izvrsen od strane node runtime-a. Konacno doso je red da require() funkcija vrati nesto. Ona vraca exports trazenog modula. Ti exporti su uskladisteni u module.exports objekat. Ukoliko zelimo da exportujemo samo jednu varijablu, npr samo jednu klasu ili samo jednu funkciju obicno koristimo module.exports i setujemo je na vrednost promenljive koju zelimo da exportujemo. S druge strane, ukoliko zelimo da exportujemo vise imenovanih varijabli, npr vise funkcija, onda bi trebali da ih napravimo kao svojstva export objekta. Npr exports.add, exports.subtract...\par
Poslednji korak jeste da se moduli zapravo kesiraju posle prvog inicijalnog ucitavanja. Ovo znaci da ako zahtevamo jedan modul vise puta, uvek cemo dobiti isti rezultat. Taj rezultat iz modula odnosno njegov kod je izvrsen samo jednom i svaki sledeci poziv - rezultat ce biti uzet is kesa. \par
\b 39. Requiring Modules in Practice\b0\par
\par
\par
\par
\par
\par
\par
}
 