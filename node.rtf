{\rtf1\ansi\ansicpg1252\deff0\nouicompat{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qc\b\f0\fs32\lang9 Node\par
\par

\pard\sa200\sl276\slmult1\fs24 Sta je zapravo NodeJS?\fs32\par

\pard\sa200\sl276\slmult1\qj\b0\fs22 Node je javascript runtime izgradjen preko google-ovog v8 javascript engina. Da razlozimo malo ovu definiciju. Do sada smo koristili javascript, medjutim koristili smo ga samo unutar browsera, jer svaki browser izvorno razume html, css i javascript jezik. Nije bitno da li pisemo vanilla JS ili pisemo neki JS framework ili biblioteku (angular, react...). Sve je to JS kod koji se izvrsva unutar browsera, jer svaki browser ima u sebi ugradjen JS \b engine\b0  (koji je zapravo samo program napisan u \b C++ \b0 jeziku i koji ce da izvrsi nas JS kod). U ovom \b slucaju browser je runtime javascripta\b0 . \par
Ali sta ako mozemo da izvedemo JS van browsera i pored toga mozemo da izvrsavamo JS jezik van browsera bez bilo kakvih ogranicanje koja imamo unutar browsera? Ispostavlja se da zapravo to mozemo da uradimo. Resenje za izvrsavanje JS van browsera jeste \b NodeJS\b0 . \b NodeJS \b0 je jos jedan javascript \b runtime\b0 , runtime mozemo da posmatramo kao neki kontejner, dakle kao neko okruzenje u kom program napisan u javascript jeziku moze da se izvrsava, \b ali van browsera\b0 !\b  \b0 Ko zapravo izvrsava taj javascript kod ako ne browser? Tu uskace \b V8 Engine \b0 koji je razvijen od strane google-a. To je upravo mesto gde ce se JS kod parsirati i izvrsiti u \b NodeJS-\b0 u. O tome kako NodeJS funkcionise bice detaljnije objasnjeno nesto kasnije. \par
Sada kada imamo JS van browsera i kada mozemo da ga izvrsavamo van browsera, drugim recima NodeJS, mozemo da radimo puno drugih stvari sa javascriptom koje su ranije bile skroz nemoguce, kao recimo stvari gde pristupamo fajlovima u sistemu, serverske sposobnosti itd. Svi ovi uslovi nam omogucavaju perfektne uslove da koristimo \b NodeJS \b0 kao \b web server. \b0 Sto drugim recima znaci da mozemo da koristimo JS na \b serveru. \b0 Dakle NodeJS mozemo da koristimo za izgradnju brzih, visoko skalabilnih mreznih aplikacija kako bi napajali \b backend \b0 nase aplikacije. \par
Prva stvar o kojoj moramo da pricamo jeste cinjenica da su NodeJS aplikacije izuzetno brze i dosta skalabilne zato sto je NodeJS \b single-threaded, baziran na dogadjajima (event-driven), non-blocking I/O model, \b0 sto ga cini izuzetno lakim i efikasnim. Ovo ga cini perfektnim za izgradnju brzih i skalabilnih aplikacija koja je intezivna sa podacima. Sto ga opet cini savrsenim za izgradnju \b API\b0 -a sa bazom podataka u pozadini, po mogucstvu ne-relacionom odnosno no-sql kao sto je recimo\b  MongoDB\b0 .  Takodje je odlican za izgradnju aplikacije gde se strimuju podaci (kao sto je YouTube), chat aplikacije ili cak server-side web aplikacije, gde se sav sadrzaj renderuje na serveru itd. \par
Naravno postoje slucajevi gde ne bi trebali da koristimo NodeJS. Ovo je slucaj kada je nasoj aplikaciji potreban super teska obrada podataka na serveru (stvari koje su zahtevne za procesor) , kao sto je recimo velika obrada slika, konverzija videa, kompresija podatak ili bilo sta slicno tome. \par
Najveca prednost NodeJS-a jeste svakako sto koristimo isti jezik i na frontu i na back-u, a to je naravno javascrit. \par
Ukoliko u terminalu ukucamo 'node' to ce pokrenuti node \b REPL\b0 , sto je skracenica za \b ReadEvalPrintLoop\b0 , sto prakticno zanci da posle ove komande mozemo da pisemo javascript kod unutar terminala! To je jos jedan pokazatelj da mozemo da pokrenemo javascript kod van browsera. Da bi izasli iz ovog node procesa mozemo da koristimo '.exit' komandu ili \b ctrl + d\b0 . Ako otvorimo opet \b REPL \b0 proces i stisnemo \b tab, \b0 to ce nam izbaciti sve globalno dostpune promenljive u NodJS-u. Takodje jos jedan trik kada pokrenemo REPL jeste da koristimo _ kako bi pristupili prethodnoj vrednosti. \par
Kako bi pokrenuli neku nodu skriptu dovoljno je da napisete 'node <ime fajla>'. \par
U NodeJS-u se dosta koristi taj koncept modula, to su jednostavno razlicite funkcionalnosti koje su uskladistene u te module. Npr da bi procitali fajlove iz sistema moramo da koristimo \b fs \b0 (sto je skracenica za file sytem)\b  \b0 modul. Kako koristimo te module, pa prosto ih zatrazimo i onda uskladistimo u neku promenljivu:\par
const fs = require('fs');\par
\par
\b Ogranicenja NodeJS-\b0 a?\par
Kao sto smo upoznati do sada, sinhroni kod moze da bude problem ukoliko neka radnja zahteva duze vreme izvrsavanja, tako da bi to blokiralo ostatak koda sve dok se ta jedna linija ne zavrsi, dakle kod sinhronog koda svaka linija ceka na prethodnu da se izvrsi pre nego sto krene sa izvrsavanjem sledeca linija. Za taj problem postoji asinhroni kod, dakle kod koji ce da se izvrsava u pozadini i sav kod kom treba duze vreme izvrsavanja bice izvrsavan u pozadini dok ostatak koda moze neometano da nastavi izvrsavanje. \par
Nesto sto mozemo da primetimo jeste da u NodeJS-u dosta koristimo callback funkcije. Prva stvar koju treba da razumemo jeste cinjenica da u NodeJS procesu, sto je zapravo mesto gde se nasa aplikacija izvrsava, postoji samo \b jedan thread\b0 . Thread je zapravo kao neki set instrukcija koji se izvrsava u kompijuterskom procesoru. Thread je mesto gde se nad kod zapravo izvrsava u procesoru nekog racunara. Sto znaci da je NodeJS zapravo \b single-threaded.\b0  Za svaku aplikaciju postoji samo jedan thread. To opet znaci da \b svi \b0 korisnici koji pristupaju vasoj aplikaciji \b koriste taj jedan thread, \b0 svi pristupaju tom jednom threadu. Kad god korisnici vrse interakciju sa aplikacijom, kod koji se izvrsava za svakog pojedinacnog korisnika bice ceo izvrsen u tom jednom threadu na istom mestu u procesoru racunara na kom je pokrenuta aplikacija, ne bitno da li imali 5 ili 5000 korisnika. To takodje znaci da kada jedan korisnik blokira taj jedan thread izvrsavanja sa nekim sinhronim kodom, svi ostali korisnicki morace da cekaju da se to sinhrono (blokirajuce) izvrsavanje zavrsi. To naravno mozda nije problem ako imamo svega 5 korisnika, ali ce definitivno biti problem za 5000 ili pola miliona korisnika \b istovremeno\b0 . Zamislite da korisnik pristupa vasoj aplikaciji i u njoj postoji veliki sinhroni kod koji iscitava neki fajl iz sistema koji ce se izvrsavati celu sekundu da bi ucitao taj fajl, to znaci da za tu jednu sekundu svi ostali korisnici ce morati da cekaju, jer je celo izvrsavanje aplikacije blokirano za tu jednu sekundu dok se ucitava taj fajl iz sistema.  Ukoliko drugi korisnici zele da rade neke prostije i manje zahtevne taskove kao sto je login unutar aplikacije ili jednostavno zahtevaju neke podatke, oni nece moci to da urade, dakle morace da cekaju da se taj fajl ucita! Tek kada se ucita taj fajl svi ostali korisnici ce biti u stanju da izvrse te svoje taskove, jedan za drugim. Ovo je naravno neprihvatljivo korisnicko iskustvo tako da je nas posao kao develera da resimo ovake situacije sa asinhronim kodom! Naravno u ovom konkretnom slucaju da bi resili ovaj problem iscitavanja nekog fajla iz sistema na sinhroni nacin, to mozemo da uradimo na asinhroni nacin. Tako da bi za istu situaciju koristili asinhroni nacin iscitavanja fajla iz sistema, koja umesto da blokira taj jedan thread, ucitava taj fajl u pozadini i ostaje u pozadini sve dok ne zavrsi iscitavanje fajla iz sistema. Posle toga registrujemo callback funckiju koje se poziva jednom kada su podaci dostpuni i ucitani. U ovom scenariu svi ostali korisnici mogu da izvrsavaju svoje taskove  u tom jednom threadu, jedan za drugim, dok se taj fajl ucitava u pozadini. Jednom kada se taj fajl ucita, pokrece se callback funkcija da bi se izvrsila u tom glavnom threadu da bi prosesirala taj ucitani fajl. Tako primenjujemo \b Non-blocking I/O model, \b0 o kom smo pricali na pocetku lekcije. I/O je skracenica za \b input/output. \b0 Ovo je jedan od glavnih razloga zato je NodeJS pun callback funkcija. U drugim programskim jezicima poput PHP-a stvari funkcionisu potpuno drugacije, tamo prakticno svaki korisnik dobija svoj jedan thread izvrsavanja, sto je potpuno druga paradigma. \par
\par
}
 