{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033\deflangfe1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.18362}{\*\mmathPr\mdispDef1\mwrapIndent1440 }\viewkind4\uc1 
\pard\nowidctlpar\sa200\sl276\slmult1\qc\b\f0\fs32\lang9 Node\par
\par

\pard\nowidctlpar\sa200\sl276\slmult1\fs24 Sta je zapravo NodeJS?\fs32\par

\pard\nowidctlpar\sa200\sl276\slmult1\qj\b0\fs22 Node je javascript runtime izgradjen preko google-ovog v8 javascript engina. Da razlozimo malo ovu definiciju. Do sada smo koristili javascript, medjutim koristili smo ga samo unutar browsera, jer svaki browser izvorno razume html, css i javascript jezik. Nije bitno da li pisemo vanilla JS ili pisemo neki JS framework ili biblioteku (angular, react...). Sve je to JS kod koji se izvrsva unutar browsera, jer svaki browser ima u sebi ugradjen JS \b engine\b0  (koji je zapravo samo program napisan u \b C++ \b0 jeziku i koji ce da izvrsi nas JS kod). U ovom \b slucaju browser je runtime javascripta\b0 . \par
Ali sta ako mozemo da izvedemo JS van browsera i pored toga mozemo da izvrsavamo JS jezik van browsera bez bilo kakvih ogranicanje koja imamo unutar browsera? Ispostavlja se da zapravo to mozemo da uradimo. Resenje za izvrsavanje JS van browsera jeste \b NodeJS\b0 . \b NodeJS \b0 je jos jedan javascript \b runtime\b0 , runtime mozemo da posmatramo kao neki kontejner, dakle kao neko okruzenje u kom program napisan u javascript jeziku moze da se izvrsava, \b ali van browsera\b0 !\b  \b0 Ko zapravo izvrsava taj javascript kod ako ne browser? Tu uskace \b V8 Engine \b0 koji je razvijen od strane google-a. To je upravo mesto gde ce se JS kod parsirati i izvrsiti u \b NodeJS-\b0 u. O tome kako NodeJS funkcionise bice detaljnije objasnjeno nesto kasnije. \par
Sada kada imamo JS van browsera i kada mozemo da ga izvrsavamo van browsera, drugim recima NodeJS, mozemo da radimo puno drugih stvari sa javascriptom koje su ranije bile skroz nemoguce, kao recimo stvari gde pristupamo fajlovima u sistemu, serverske sposobnosti itd. Svi ovi uslovi nam omogucavaju perfektne uslove da koristimo \b NodeJS \b0 kao \b web server. \b0 Sto drugim recima znaci da mozemo da koristimo JS na \b serveru. \b0 Dakle NodeJS mozemo da koristimo za izgradnju brzih, visoko skalabilnih mreznih aplikacija kako bi napajali \b backend \b0 nase aplikacije. \par
Prva stvar o kojoj moramo da pricamo jeste cinjenica da su NodeJS aplikacije izuzetno brze i dosta skalabilne zato sto je NodeJS \b single-threaded, baziran na dogadjajima (event-driven), non-blocking I/O model, \b0 sto ga cini izuzetno lakim i efikasnim. Ovo ga cini perfektnim za izgradnju brzih i skalabilnih aplikacija koja je intezivna sa podacima. Sto ga opet cini savrsenim za izgradnju \b API\b0 -a sa bazom podataka u pozadini, po mogucstvu ne-relacionom odnosno no-sql kao sto je recimo\b  MongoDB\b0 .  Takodje je odlican za izgradnju aplikacije gde se strimuju podaci (kao sto je YouTube), chat aplikacije ili cak server-side web aplikacije, gde se sav sadrzaj renderuje na serveru itd. \par
Naravno postoje slucajevi gde ne bi trebali da koristimo NodeJS. Ovo je slucaj kada je nasoj aplikaciji potreban super teska obrada podataka na serveru (stvari koje su zahtevne za procesor) , kao sto je recimo velika obrada slika, konverzija videa, kompresija podatak ili bilo sta slicno tome. \par
Najveca prednost NodeJS-a jeste svakako sto koristimo isti jezik i na frontu i na back-u, a to je naravno javascrit. \par
Ukoliko u terminalu ukucamo 'node' to ce pokrenuti node \b REPL\b0 , sto je skracenica za \b ReadEvalPrintLoop\b0 , sto prakticno zanci da posle ove komande mozemo da pisemo javascript kod unutar terminala! To je jos jedan pokazatelj da mozemo da pokrenemo javascript kod van browsera. Da bi izasli iz ovog node procesa mozemo da koristimo '.exit' komandu ili \b ctrl + d\b0 . Ako otvorimo opet \b REPL \b0 proces i stisnemo \b tab, \b0 to ce nam izbaciti sve globalno dostpune promenljive u NodJS-u. Takodje jos jedan trik kada pokrenemo REPL jeste da koristimo _ kako bi pristupili prethodnoj vrednosti. \par
Kako bi pokrenuli neku nodu skriptu dovoljno je da napisete 'node <ime fajla>'. \par
U NodeJS-u se dosta koristi taj koncept modula, to su jednostavno razlicite funkcionalnosti koje su uskladistene u te module. Npr da bi procitali fajlove iz sistema moramo da koristimo \b fs \b0 (sto je skracenica za file sytem)\b  \b0 modul. Kako koristimo te module, pa prosto ih zatrazimo i onda uskladistimo u neku promenljivu:\par
const fs = require('fs');\par
\par
\b Ogranicenja NodeJS-\b0 a?\par
Kao sto smo upoznati do sada, sinhroni kod moze da bude problem ukoliko neka radnja zahteva duze vreme izvrsavanja, tako da bi to blokiralo ostatak koda sve dok se ta jedna linija ne zavrsi, dakle kod sinhronog koda svaka linija ceka na prethodnu da se izvrsi pre nego sto krene sa izvrsavanjem sledeca linija. Za taj problem postoji asinhroni kod, dakle kod koji ce da se izvrsava u pozadini i sav kod kom treba duze vreme izvrsavanja bice izvrsavan u pozadini dok ostatak koda moze neometano da nastavi izvrsavanje. \par
Nesto sto mozemo da primetimo jeste da u NodeJS-u dosta koristimo callback funkcije. Prva stvar koju treba da razumemo jeste cinjenica da u NodeJS procesu, sto je zapravo mesto gde se nasa aplikacija izvrsava, postoji samo \b jedan thread\b0 . Thread je zapravo kao neki set instrukcija koji se izvrsava u kompijuterskom procesoru. Thread je mesto gde se nad kod zapravo izvrsava u procesoru nekog racunara. Sto znaci da je NodeJS zapravo \b single-threaded.\b0  Za svaku aplikaciju postoji samo jedan thread. To opet znaci da \b svi \b0 korisnici koji pristupaju vasoj aplikaciji \b koriste taj jedan thread, \b0 svi pristupaju tom jednom threadu. Kad god korisnici vrse interakciju sa aplikacijom, kod koji se izvrsava za svakog pojedinacnog korisnika bice ceo izvrsen u tom jednom threadu na istom mestu u procesoru racunara na kom je pokrenuta aplikacija, ne bitno da li imali 5 ili 5000 korisnika. To takodje znaci da kada jedan korisnik blokira taj jedan thread izvrsavanja sa nekim sinhronim kodom, svi ostali korisnicki morace da cekaju da se to sinhrono (blokirajuce) izvrsavanje zavrsi. To naravno mozda nije problem ako imamo svega 5 korisnika, ali ce definitivno biti problem za 5000 ili pola miliona korisnika \b istovremeno\b0 . Zamislite da korisnik pristupa vasoj aplikaciji i u njoj postoji veliki sinhroni kod koji iscitava neki fajl iz sistema koji ce se izvrsavati celu sekundu da bi ucitao taj fajl, to znaci da za tu jednu sekundu svi ostali korisnici ce morati da cekaju, jer je celo izvrsavanje aplikacije blokirano za tu jednu sekundu dok se ucitava taj fajl iz sistema.  Ukoliko drugi korisnici zele da rade neke prostije i manje zahtevne taskove kao sto je login unutar aplikacije ili jednostavno zahtevaju neke podatke, oni nece moci to da urade, dakle morace da cekaju da se taj fajl ucita! Tek kada se ucita taj fajl svi ostali korisnici ce biti u stanju da izvrse te svoje taskove, jedan za drugim. Ovo je naravno neprihvatljivo korisnicko iskustvo tako da je nas posao kao develera da resimo ovake situacije sa asinhronim kodom! Naravno u ovom konkretnom slucaju da bi resili ovaj problem iscitavanja nekog fajla iz sistema na sinhroni nacin, to mozemo da uradimo na asinhroni nacin. Tako da bi za istu situaciju koristili asinhroni nacin iscitavanja fajla iz sistema, koja umesto da blokira taj jedan thread, ucitava taj fajl u pozadini i ostaje u pozadini sve dok ne zavrsi iscitavanje fajla iz sistema. Posle toga registrujemo callback funckiju koje se poziva jednom kada su podaci dostpuni i ucitani. U ovom scenariu svi ostali korisnici mogu da izvrsavaju svoje taskove  u tom jednom threadu, jedan za drugim, dok se taj fajl ucitava u pozadini. Jednom kada se taj fajl ucita, pokrece se callback funkcija da bi se izvrsila u tom glavnom threadu da bi prosesirala taj ucitani fajl. Tako primenjujemo \b Non-blocking I/O model, \b0 o kom smo pricali na pocetku lekcije. I/O je skracenica za \b input/output. \b0 Ovo je jedan od glavnih razloga zato je NodeJS pun callback funkcija. U drugim programskim jezicima poput PHP-a stvari funkcionisu potpuno drugacije, tamo prakticno svaki korisnik dobija svoj jedan thread izvrsavanja, sto je potpuno druga paradigma. \par
\par
\b Introduction to NPM\par
NPM \b0 jeste software koji koristimo za upravljanje sa third party open-source paketima koje biramo da ukljucimo u nas projekat (express, react\'85)\par
Node paket menadzer jeste command line interfejs koja automatski dolazi ukljucena uz node js I koju takodje koristimo da instaliramo I da upravljamo sa open-srouce paketima. Ovi paketi koje smo spomenuli obicno dolaze iz package repozitorijuma koji je takodje NPM. Na npm.js sajtu mozete da vidite sve patkete koji su ukljucueni u repozitorijumu NPM-a. Sto znaci da je NPM I command line iinterfejs koji koristimo da upravljamo tim paketima I u isto vreme jeste I sam repozitorijum sve te pakete. \par
Kada krecemo sa NPM obicno prvo sto radimo jeste da pokrecemo komandu \b npm init, \b0 ovo ce prakticno za nas kreiratni \b package.json\b0  fajl. To je nesto kao konfiguracijski fajl naseg projekta, tu se skladiste razlicite informacije o nasem projektu. Kada budemo krenuli da instaliramo pakete za nas projekat oni ce automatski biti dodati ovde u package.json fajlu tako da mozemo da pratimo koje sve pakete imamo u nasem projektu.   \par
Dva tipa paketa koji mozemo da instaliramo su proste dependencije ili development dependencije. Te proste ili regularne dependecije su prosto paketi koji ukljucuju kod koji cemo mi da ukljucimo unutar naseg koda. Zato ih nazivamo dependencije zato sto nas kod zavisi od njih da radi kako treba. \par
Da bi instalirali neki paket iz NPM-a dovoljno je da iskucamo \b npm install <ime paketa>. \b0 Takodje mozemo da koristimo skracenicu i da napisemo samo slovo \b i \b0 umesto \b install.\par
npm i slugify\par
\b0 Nekada je bilo obavezno staviti i \b --save \b0 na kraju medjutim vise nije neophodno. Dakle pakete koje instaliramo uz pomoce komande \b npm install <ime paketa> \b0 bice instalirani kao proste dependencije i bice dodate pod dependency svojstvom unutar \b package.json\b0  fajlu. \b\par
\b0 Pored ovih prostih dependencija imamo i \b development \b0 dependencije, ovo su samo alati za razvoj (development) aplikacije (stvari poput kod bandlera kao sto je webpack, ili kao sto je debugger alat za testiranje). Ove development   dependencije sluze samo za development okruzenje nisu neophodne za produkciju. Posto nas kod zapravo ne zavisi od njih. Primer jednog takvog development dependent paketa jeste \b nodemon\b0 . Nodemon paket nam pomaze da razvijamo node aplikaciju tako sto automatski restartuje node aplikaciju kada sacuvamo nas kod. \par
Development dependencije instaliramo ovako: \b npm install nodemon --save-dev \b0 ili mozemo da koristimo komandu \b npm install nodemon -D\line\b0 Ova komanda ce da kaze npm-u da zelimo da je smestimo unutar devDependency-a unutar package.json fajla. \par
Sada kada smo pricali o dva tipa dependencija, da kazemo koju rec i o dva tipa instaliranja dependencija. Jer za sada smo instalirali ove pakete samo lokalno, to znaci da ce one raditi samo u ovom projektu, tu kod nas na racunaru. Prilikom instaliranja paketa mozemo da primetimo da je npm dodao kod nas \b node_modules \b0 folder i tu upakovao sve dependencije naseg projekta. Ako otvorimo taj node_modules folder videcemo da se tu nalazio veliki broj foldera dok smo mi za sada instalirali samo dva paketa \b slugify \b0 kao obican dependecy i \b nodemon \b0 kao development dependency, cemu onda sluze ostali paketi. Pa ti folderi sadrze dependencije nasih dependencija, jer npr nas paket \b slugify \b0 zahteva vise tih paketa da bi funkcionisa kako treba. Dakle ceo taj folder node_modules-a \tab sluzi za nasu lokalnu aplikaciju. \par
Uz npm imamo nacin instaliranja paketa globalno. Te pakete koje smo globalno instalirali bice dostpuni bilo gde, ne samo u nasem lokalnom folderu, vec u svim folderima na nasem racunaru. Tako da na primer posto nodemon moze da posluzi za razvitak node aplikacija, mozemo da ga instaliramo globalno kako bi bio dostuupan u svim nasim folderima i svuda na nasem racunaru. Tako nemoramo da ga instaliramo svaki put kada kreiramo novi projekat. \par
Primer instaliranja nekog paketa globalno na vasem racunaru: \b npm install nodemon --global\par
\b0 Sada kada imamo instlairan nodemon globalno mozemo da ga koristimo za razvoj nase node aplikacije tako sto cemo da iskucamo komandu u terminalu \b nodemon index.js (odnosno ime fajla koji zelimo da pokrenemo).\par
\b0 Recimo da nismo instalirali nodemon globalno, kako bi ga onda koristili kao devDependecy lokalno kod nas u folderu gde nam se nalazi aplikacija. Ne bi mogli samo da ga pokrenemo iz comman line-a, zato sto lokalni dependecy ne rade na taj nacin. Ne mozemo da ih koristimo tek tako unutar terminala. Ali ono sto mozemo da radimo jeste da odredimo npm skriptu. Te skripte mozemo da nadjemo pod svojstvom "\b scripts"\b0  unutar package.json fajla. Prilikom npm init komande ona je za nas dodala vec jednu skriptu za test.  \par
Sada mozemo da napravimo nasu start skriptu i da napisemo "nodemon index.js". Tako da sada umesto da pokrecemo komandu dole u terminalu mozemo da stavimo tu komandu pod npm skriptu. Npm skriptu porecemo tako sto ukucamo \b npm run start\b0 . Na ovaj nacin cemo da koristimo nas lokalni devDependecy a ne globalni nodemon. Posto je start skripta nekako podrazumevana kada pokrecemo start skriptu ne moramo cak ni da kucam \b run, \b0 dovoljno je samo \b npm start.\par
\par
Verzije paketa\par
\b0 Svaka verizija npm paketa prati standard notacije semanticke vrednosti, sto znaci da se verzije paketa uvek izrazavaju sa po tri broja. Prvi broj jeste velika verzija. Drugi broj je manja verzija i treci broj je patch verzija. \par
"nodemon": "^2.0.21"\par
Treci broj, sluzi samo da se odkloni neki bug. Recimo da su developeri pronasli gresku u prethodnoj verziji, odmah po odklanjanju tog bug-a promenice patch broj ili ti treci broj.  \par
Drugi broj je manja verzija. Ova verzija predstavlja uvedjenje nekih novih mogucnosti u paket, ali to nisu velike promene. Sto znaci da sve promene koje se odnose na drugi broj bice kompatibilne sa prethodnim brojevima. \par
Prvi broj je velika verzija. Ovaj broj se menja samo kada dodje do velike promene u paketu koji moze da ima promene koje nece raditi sa prethodnim verzijama. Ukoliko se prvi broj promeni to znaci da nas kod mozda nece raditi ako nam je prvi broj manji od trenutnog. \par
"nodemon": "\b ^\b0 2.0.21"\par
Sto se tice simbola koji dolaze ispred broja verzije paketa, on odredjuje koji update mi prihvatamo za svaki od paketa. Ovaj simbol koji npm paket podrazumevano odredjduje, znaci da mi prihvatamo patch u manjoj verziji. \par
\b ^ - \b0 ako smo rekli da ovaj znak predstavlja zapravo da mi prihvatamo sve patch-eve i sve manje promene verzija (dakle drugi i treci broj). Mi to mozemo da promenimo. Mozemo da ga promenimo u ovaj simbol: \b ~.\par
~ - \b0 Ovaj znak predstavlja da sada prihvatamo samo patch promene u nasoj verziji (dakle samo treci broj), sto ga cini dosta sigurnijim od prvog znaka. \par
\b Kako zapravo updateujemo pakete? \par
\b0 Pakete updateujemo tako sto koristimo komandu \b npm update <ime paketa>\b0\line Naravno ovo ce biti direktno povezano sa znakom koji stoji ispred verzije, dakle ako je znak \b ^ \b0 onda to znaci da nas update da ukljuci promenu drugog i treceg broja, manje promene i patch prmene, dok ako ispred nase verzije stoji znak \b ~ \b0 to znaci da ce update da ukljuci samo najnoviji patch pa toj treutnoj verziji, jer ovaj znak prihvata promene samo treceg broja, odnosno patch promene. \b\par
\b0 Ono sto mozemo da napravimo jeste da ukucamo u terminal \b npm outdated\b0  i to treba da nam da tabelu gde ce biti prikazani paketi koji nisu najnoviji. Ono sto takodje mozemo da uradimo sa npm-om jeste da instaliramo paket po odredjenoj verziji tako sto dodamo posle paketa tacan broj verzije koji zelimo da instaliramo, npr:\par
\b npm install slugify@1.0.0\par
\b0 Brisanje paketa vrsimo tako sto napisemo \b npm uninstall <ime paketa>\b0\par
\par
Naravno ono sto je bitno da razumemo sto se tice \b node_modules\b0  foldera jeste da nikada necemo da ga delimo sa nekim ili nikada necemo da saljemo node_modules folder na git repozitorijum prvo zato sto on dosta zauzima a drugo jer lako mozemo da dodjemo do njega preko npm-a. Ako radimo neki projekat na jednom racunaru pa zatim predjemo na neki drugi racunar to vrlo lako mozemo da uradimo pomocu komande \b npm install \b0 sto ce zapravo pogledati u package.json folder i instalirati sve pakete od npm-a koje nadje u package.json fajlu. \par
}
 